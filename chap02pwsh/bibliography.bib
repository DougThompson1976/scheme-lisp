@book{springer_scheme,
	title = {Scheme and the {Art} of {Programming}},
	language = {en},
	author = {Springer, George and Friedman, Daniel P.},
	keywords = {continuations, scheme},
	file = {Scheme and the Art of Programming.pdf:/home/andrei/Zotero/storage/3YHUJNNQ/Scheme and the Art of Programming.pdf:application/pdf}
}


@inproceedings{friedman_applications_1988,
	title = {Applications of continuations},
	author = {Friedman, Daniel P},
	year = {1988},
	keywords = {continuations, scheme},
	file = {appcont.pdf:/home/andrei/Zotero/storage/BUJHTYHC/appcont.pdf:application/pdf}
}


@article{reynolds_discoveries_1993,
	title = {The discoveries of continuations},
	volume = {6},
	issn = {0892-4635, 1573-0557},
	url = {http://link.springer.com/10.1007/BF01019459},
	doi = {10.1007/BF01019459},
	abstract = {We give a brief account of the discoveries of continuations and related concepts by A. van Wijngaarden, A. W. Mazurkiewicz, F. L. Morris, C. P. Wadsworth, J. H. Morris, M. J. Fischer, and S. K. Abdali.},
	language = {en},
	number = {3-4},
	urldate = {2019-02-28},
	journal = {LISP and Symbolic Computation},
	author = {Reynolds, John C.},
	month = nov,
	year = {1993},
	keywords = {continuations, scheme, algol},
	pages = {233--247},
	file = {Reynolds - 1993 - The discoveries of continuations.pdf:/home/andrei/Zotero/storage/J3ZYVPWM/Reynolds - 1993 - The discoveries of continuations.pdf:application/pdf}
}


@misc{wikic2_call,
	title = {Call {With} {Current} {Continuation}},
	url = {http://wiki.c2.com/?CallWithCurrentContinuation},
	howpublished= {\url{http://wiki.c2.com/?CallWithCurrentContinuation}},
	urldate = {2019-03-01},
	keywords = {continuations, scheme},
	file = {Call With Current Continuation:/home/andrei/Zotero/storage/IVGDBV88/wiki.c2.com.html:text/html}
}


@misc{thielecke_continuations,
	title = {Continuations, functions and jumps},
	shorttitle = {Logiccolumn8.pdf},
	url = {http://www.cs.bham.ac.uk/~hxt/research/Logiccolumn8.pdf},
	urldate = {2019-03-04},
	author = {Thielecke, Hayo},
	keywords = {continuations},
	file = {Logiccolumn8.pdf:/home/andrei/Zotero/storage/3WF4RVGG/Logiccolumn8.pdf:application/pdf}
}


@misc{against_callcc,
	title = {An argument against call/cc},
	url = {http://okmij.org/ftp/continuations/against-callcc.html},
	howpublished = {\url{http://okmij.org/ftp/continuations/against-callcc.html}},
	urldate = {2019-03-06},
	keywords = {continuations, scheme},
	file = {An argument against call/cc:/home/andrei/Zotero/storage/HKIRARSX/against-callcc.html:text/html}
}


@misc{continuations_by_example,
	title = {Coroutines, exceptions, time-traveling search, generators and threads: {Continuations} by example},
	author = {Might, Matt},
	url = {http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/},
	urldate = {2019-03-07},
	keywords = {continuations, scheme},
	file = {Coroutines, exceptions, time-traveling search, generators and threads\: Continuations by example:/home/andrei/Zotero/storage/A4Q2DHAS/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines.html:text/html}
}

@book{queinnec_lisp,
	title = {Lisp in {Small} {Pieces}},
	language = {en},
	author = {Queinnec, Christian},
	keywords = {continuations, scheme, lisp, common lisp},
	file = {Queinnec and Callaway - Lisp in Small Pieces.pdf:/home/andrei/Zotero/storage/BES84LB2/Queinnec and Callaway - Lisp in Small Pieces.pdf:application/pdf}
}

@article{abelson_structure_1997,
	title = {Structure and interpretation of computer programs, (second edition)},
	volume = {33},
	issn = {08981221},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S0898122197900511},
	doi = {10.1016/S0898-1221(97)90051-1},
	language = {en},
	number = {4},
	urldate = {2019-02-28},
	journal = {Computers \& Mathematics with Applications},
	author = {Abelson and Sussman},
	month = feb,
	year = {1997},
	keywords = {scheme, lisp},
	pages = {133},
	file = {1997 - Structure and interpretation of computer programs,.pdf:/home/andrei/Zotero/storage/J6DP6EF2/1997 - Structure and interpretation of computer programs,.pdf:application/pdf}
}

@misc{wikic2_homoiconic,
	title = {Homoiconic {Languages}},
	url = {http://wiki.c2.com/?HomoiconicLanguages},
	howpublished = {\url{http://wiki.c2.com/?HomoiconicLanguages}},
	urldate = {2019-03-09},
	keywords = {lisp},
	file = {Homoiconic Languages:/home/andrei/Zotero/storage/74J3PNGR/wiki.c2.com.html:text/html}
}


@book{payette_windows_2007,
	address = {Greenwich, Conn. : London},
	title = {Windows {PowerShell} in action},
	isbn = {978-1-932394-90-0},
	language = {en},
	publisher = {Manning ; Pearson Education [distributor]},
	author = {Payette, Bruce G.},
	year = {2007},
	note = {OCLC: ocm72151671},
	keywords = {PowerShell},
	file = {Payette - 2007 - Windows PowerShell in action.pdf:/home/andrei/Zotero/storage/CDUFJLFJ/Payette - 2007 - Windows PowerShell in action.pdf:application/pdf}
}

@book{jones_learn_2017,
	address = {Shelter Island},
	edition = {Third edition},
	title = {Learn {Windows} {PowerShell} in a month of lunches},
	isbn = {978-1-61729-416-7},
	abstract = {Learn Windows PowerShell in a Month of Lunches, Third Edition is an innovative tutorial designed for busy IT professionals. This updated edition covers PowerShell features that run on Windows 7, Windows Server 2008 R2 and later, PowerShell v3 and later, and includes v5 features like PowerShellGet. About the Technology PowerShell is both a scripting language and an administrative shell that lets you control and automate nearly every aspect of Windows. It accepts and executes commands interactively and you can write scripts to manage most Windows servers like Exchange, IIS, and SharePoint, as well as online services like Azure and Office 365. About the Book Learn Windows PowerShell in a Month of Lunches, Third Edition is an innovative tutorial designed for busy IT professionals. Just set aside one hour a day - lunchtime would be perfect - for a month, and you'll be automating Windows tasks faster than you ever thought possible. This updated edition covers PowerShell features that run on Windows 7, Windows Server 2008 R2 and later, PowerShell v3 and later, and includes v5 features like PowerShellGet. What's Inside Learn PowerShell from the beginning, no experience required! Covers PowerShell v3 and up, Windows 7, and Windows Server 2008 R2 and later Each lesson takes you an hour or less About the Reader Experience with Windows administration is helpful. No programming or scripting experience needed. About the Author Veteran PowerShell MVPs Don Jones and Jeffery Hicks bring years as successful trainers to this concise, easy-to-follow book. Table of Contents Before you begin Meet PowerShell Using the help system Running commands Working with providers The pipeline: connecting commands Adding commands Objects: data by another name The pipeline, deeper Formatting - and why it's done on the right Filtering and comparisons A practical interlude Remote control: one-to-one, and one-to-many Using Windows Management Instrumentation and CIM Multitasking with background jobs Working with many objects, one at a time Security alert! Variables: a place to store your stuff Input and output Sessions: remote control with less work You call this scripting? Improving your parameterized script Advanced remoting configuration Using regular expressions to parse text files Additional random tips, tricks, and techniques Using someone else's script Never the end PowerShell cheat sheet.--},
	language = {en},
	publisher = {Manning},
	author = {Jones, Don and Hicks, Jeffrey T.},
	year = {2017},
	note = {OCLC: ocn967775445},
	keywords = {PowerShell, Windows},
	file = {Jones and Hicks - 2017 - Learn Windows PowerShell in a month of lunches.pdf:/home/andrei/Zotero/storage/WNC72CSI/Jones and Hicks - 2017 - Learn Windows PowerShell in a month of lunches.pdf:application/pdf}
}


@book{the_devops_collective_monad_2016,
	title = {The {Monad} {Manifesto}, {Annotated}},
	url = {https://leanpub.com/themonadmanifestoannotated},
	abstract = {The Monad Manifesto is the original Jeffrey Snover-authored document that results in the Windows PowerShell we know today. This version includes community-contributed annotations, notes, and expansions.},
	language = {undefined},
	urldate = {2019-02-28},
	publisher = {Leanpub},
	author = {The DevOps Collective, Inc},
	month = may,
	year = {2016},
	keywords = {PowerShell},
	file = {Snapshot:/home/andrei/Zotero/storage/S8P5U225/themonadmanifestoannotated.html:text/html}
}


@misc{jensen_tips,
	title = {Tips for {Writing} {Cross}-{Platform} {PowerShell} {Code} {\textbar} {PowerShell}.org},
	url = {https://powershell.org/2019/02/tips-for-writing-cross-platform-powershell-code/},
	language = {en-US},
	urldate = {2019-02-28},
	author = {Jensen, Aaron},
	keywords = {PowerShell},
	file = {Snapshot:/home/andrei/Zotero/storage/QRY47ZGL/tips-for-writing-cross-platform-powershell-code.html:text/html}
}


@article{tanter_beyond,
	title = {Beyond static and dynamic scope},
	abstract = {Traditional treatment of scoping in programming languages considers two opposite semantics: static scoping, where the scope of a binding is a block of program text, and dynamic scoping, where a binding is in effect during the whole reduction of an expression to a value. Static scoping and dynamic scoping are however but two points in the design space of scoping mechanisms. As a result, most proposed language mechanisms that rely on some notion of scoping, such as variable bindings of course, but also more exotic ones like aspects and mixin layers, adopt either one or the other semantics. As it turns out, these two semantics are sometimes too extreme, and a mixture of both is needed. To achieve this, language designers and/or programmers have to resort to ad hoc solutions. We present a general scoping model that simply expresses static and dynamic scoping, and that goes further by allowing Ô¨Åne-grained exploration of the design space of scoping. The model, called scoping strategies, gives precise control over propagation and activation of language mechanisms. While we have already studied it for aspects, we hereby show that the model is not restricted to aspects, by treating in depth its application to the most standard kind of adaptation: variable bindings. We also brieÔ¨Çy discuss its application to mixin layers, and program monitoring. We believe that research in programming language constructs can beneÔ¨Åt from a more Ô¨Çexible notion of scoping that goes beyond the static/dynamic dichotomy.},
	language = {en},
	author = {Tanter, Eric},
	pages = {11},
	file = {Tanter - Beyond static and dynamic scope.pdf:/home/andrei/Zotero/storage/DDXCRGAN/Tanter - Beyond static and dynamic scope.pdf:application/pdf}
}


@inproceedings{stallman_emacs:_1981,
	title = {{EMACS}: {The} {Extensible}, {Customizable} {Display} {Editor}},
	url = {https://www.gnu.org/software/emacs/emacs-paper.html},
	howpublished = {\url{https://www.gnu.org/software/emacs/emacs-paper.html}},
	language = {English},
	urldate = {2019-03-17},
	author = {Stallman, Richard},
	year = {1981},
	keywords = {lisp, scope, Text Editing},
	file = {Snapshot:/home/andrei/Zotero/storage/3FTUU2HG/emacs-paper.html:text/html}
}

@misc{given_re:_2009,
	title = {Re: {Coroutines} and {Go}},
	url = {http://lua-users.org/lists/lua-l/2009-11/msg00576.html},
	howpublished = {\url{http://lua-users.org/lists/lua-l/2009-11/msg00576.html}},
	urldate = {2019-03-24},
	author = {Given, David},
	month = nov,
	year = {2009},
	keywords = {compilers},
	file = {Re\: Coroutines and Go:/home/andrei/Zotero/storage/VABJLNNL/msg00576.html:text/html}
}

@misc{graham_roots_2002,
	title = {The {Roots} of {Lisp}},
	author = {Graham, Paul},
	month = jan,
	year = {2002},
	file = {jmc-1.ps:/home/andrei/Zotero/storage/U78QEKZG/jmc-1.ps:application/postscript}
}

@inproceedings{reynolds_definitional_1998,
	address = {Boston, Massachusetts, United States},
	title = {Definitional interpreters for higher-order programming languages},
	abstract = {Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually deÔ¨Åned by interpreters that are themselves written in a programming language based on the lambda calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy‚Äôs deÔ¨Ånition of LISP, Landin‚Äôs SECD machine, the Vienna deÔ¨Ånition of PL/I, Reynolds‚Äô deÔ¨Ånitions of GEDANKEN, and recent unpublished work by L. Morris and C. Wadsworth. Such deÔ¨Ånitions can be classiÔ¨Åed according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call by value versus call by name) in the deÔ¨Åned language depends upon the order of application in the deÔ¨Åning language. As an example, we consider the deÔ¨Ånition of a simple applicative programming language by means of an interpreter written in a similar language. DeÔ¨Ånitions in each of the above classiÔ¨Åcations are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.},
	language = {en},
	urldate = {2019-03-07},
	author = {Reynolds, John C.},
	year = {1998},
	keywords = {continuations},
	file = {Reynolds - 1972 - Definitional interpreters for higher-order program.pdf:/home/andrei/Zotero/storage/XBFQKGJI/Reynolds - 1972 - Definitional interpreters for higher-order program.pdf:application/pdf}
}
