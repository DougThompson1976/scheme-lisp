(define (atom? x)
 (not (pair? x)))

(define (caddr x)
 (cadr (cdr x)))

(define (cadddr)
 (caddr (cdr x)))

(define (wrong message . tail)
 (display message)
 (if (not (null? tail))
  (display tail)))

(define (evaluate2 e env)
 (if (atom? e)
  (cond ((symbol? e) (lookup e env))
   ((or (number? e) (string? e) (char? e) (boolean? e))
   e)
   (else (wrong "Cannot evaluate" e)))
 (case (car e)
   ((quote) (cadr e))
   ((if) (if (evaluate (cadr e) env)
          (evaluate (caddr e) env)
          (evaluate (cadddr e) env)))
   ((begin) (eprogn (cdr e) env))
   ((set!) (update! (cadr e) env))
   ((lambda) (make-function (cadr e) (cddr e) env))
   (else  (invoke (evaluate (car e) env)
                  (evlis (cdr e) env))))))

(define (eprogn exps env)
 (if (pair? exps)
  (if (pair? (cdr exps))
   (begin
     (evaluate (car exps) env)
     (eprogn (cdr exps) env))
   '())))

(define (lookup id env)
 (if (pair? env) ; lookup uses host evaluator for consequent !!!
    (if (eq? (caar env) id)
     (cdar env)
     (lookup id (cdr env)))
  (wrong "No such binding" id)))

(define (update! id env value)
 (if (pair? env)
  (if (eq? (caar env) id)
   (begin
     (set-cdr! (car env) value)
     value)
   (update! id (cdr env) value))
  (wrong "No such binding" id)))

(define (evlis exps env)
 (if (pair? exps)
  (let ((argument1 (evaluate (car exps) env)))
   (cons argument1 (evlis (cdr exps) env)))
  '()))

(define (extend env variables values)
 (cond ((pair? variables)
        (if (pair? values)
         (cons (cons (car variables) (car values))
          (extend env (cdr variables) (cdr values)))
         (wrong "Not enough variables")))
  ((null? variables)
   (if (null? values)
    env
    (wrong "Too many values")))
  ((symbol? variables)
   (cons (cons variables values) env))))

(define (invoke fn args)
 (display "INVOKE")
 (display fn)
 (display args)
 (if (procedure? fn)
  (apply fn args)
  (wrong "Not a function" fn)))

(define (make-function variables body env)
 (lambda (values)
  (eprogn body (extend env variables values))))

(define env.init '())

(define env.global env.init)

(define (set-global name value)
 (set! env.global (cons (cons name value) env.global)))

(set-global 'nil nil)
(set-global '#t #t)
(set-global '#f #f)
(set-global 'cons cons)
(set-global 'car car)
(set-global 'caar caar)
(set-global 'cdar cdar)
(set-global 'cadr cadr)
(set-global 'cddr cddr)
(set-global 'cdr cdr)
(set-global 'set-cdr! set-cdr!)
(set-global '+ +)
(set-global 'eq? eq?)
(set-global '< <)
(set-global 'display display)
(set-global 'symbol? symbol?)
(set-global 'atom? (lambda (x) (not (pair? x))))
(set-global 'number? number?)
(set-global 'string? string?)
(set-global 'char? char?)
(set-global 'pair? pair)
(set-global 'boolean? boolean?)


;(define (eval0 e env)
; (if (atom? e)
;  (cond ((symbol? e) (lookup e env))
;   ((or (number? e) (string? e) (char? e) (boolean? e))
;    e)
;   (else (wrong "Cannot evaluate" e))))
; (case (car e)
;   ((quote) (cadr e))
;   ((if) (if (evaluate (cadr e) env)
;          (evaluate (caddr e) env)
;          (evaluate (cadddr e) env)))
;   ((begin) (eprogn (cdr e) env))
;   ((set!) (update! (cadr e) env))
;   ((lambda) (make-function (cadr e) (cddr e) env))
;   (else  (invoke (evaluate (car e) env)
;                  (evlis (cdr e env))))))

(define (evaluate e env)
 (display "EVALUATE")
 (display e)
 (if (atom? e)
  (cond ((symbol? e) (lookup e env))
   ((or (number? e) (string? e) (char? e) (boolean? e))
    e)
   (else (wrong "Cannot evaluate" e)))
  (case (car e)
    ((quote) (cadr e))
    ((if) (if (evaluate (cadr e) env)
           (evaluate (caddr e) env)
           (evaluate (cadddr e) env)))
    ((begin) (eprogn (cdr e) env))
    ((set!) (update! (cadr e) env))
    ((lambda) (make-function (cadr e) (cddr e) env))
    (else
        (invoke (evaluate (car e) env) (evlis (cdr e) env))))))

;(display env.global)

;(display display)                           ; exception in evaluator: lookup returns null
;(+ 4 5) returns null!
(define (chap01)
  (define (toplevel)
  (display (evaluate (read) env.global))
    (toplevel))
  (toplevel))
